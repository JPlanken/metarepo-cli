package cli

import (
	"fmt"
	"os"
	"sort"
	"strings"
	"time"

	"github.com/JPlanken/metarepo-cli/internal/git"
	"github.com/spf13/cobra"
)

var inventoryCmd = &cobra.Command{
	Use:   "inventory",
	Short: "Inventory management commands",
	Long:  `Commands for managing the repository inventory.`,
}

var inventoryGenerateCmd = &cobra.Command{
	Use:   "generate",
	Short: "Generate REPOS.md inventory file",
	Long:  `Generate a markdown file listing all repositories in the workspace.`,
	RunE:  runInventoryGenerate,
}

var (
	inventoryOutput string
	inventoryFormat string
)

func init() {
	rootCmd.AddCommand(inventoryCmd)
	inventoryCmd.AddCommand(inventoryGenerateCmd)

	inventoryGenerateCmd.Flags().StringVarP(&inventoryOutput, "output", "o", "REPOS.md", "output file path")
	inventoryGenerateCmd.Flags().StringVarP(&inventoryFormat, "format", "f", "markdown", "output format (markdown, simple)")
}

func runInventoryGenerate(cmd *cobra.Command, args []string) error {
	fmt.Println("Scanning for repositories...")

	repos, err := git.ScanForRepos(".")
	if err != nil {
		return fmt.Errorf("failed to scan for repositories: %w", err)
	}

	if len(repos) == 0 {
		fmt.Println("No repositories found.")
		return nil
	}

	// Sort by name
	sort.Slice(repos, func(i, j int) bool {
		return repos[i].Name < repos[j].Name
	})

	var content string
	if inventoryFormat == "simple" {
		content = generateSimpleInventory(repos)
	} else {
		content = generateMarkdownInventory(repos)
	}

	if err := os.WriteFile(inventoryOutput, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write inventory: %w", err)
	}

	fmt.Printf("Generated %s with %d repositories.\n", inventoryOutput, len(repos))
	return nil
}

func generateMarkdownInventory(repos []*git.RepoInfo) string {
	var sb strings.Builder

	sb.WriteString("# Repository Overview\n\n")
	sb.WriteString(fmt.Sprintf("*Generated: %s*\n\n", time.Now().Format("2006-01-02 15:04:05")))
	sb.WriteString(fmt.Sprintf("Total repositories: **%d**\n\n", len(repos)))

	sb.WriteString("## Repositories\n\n")
	sb.WriteString("| Repository | Branch | Last Commit | Remote |\n")
	sb.WriteString("|------------|--------|-------------|--------|\n")

	for _, repo := range repos {
		branch := repo.Branch
		if repo.IsDetached {
			branch = "(detached)"
		}

		lastCommit := "-"
		if !repo.LastCommit.Date.IsZero() {
			lastCommit = repo.LastCommit.Date.Format("2006-01-02")
		}

		remote := "-"
		if repo.HasRemote {
			// Truncate long URLs
			remote = repo.URL
			if len(remote) > 50 {
				remote = remote[:47] + "..."
			}
		}

		sb.WriteString(fmt.Sprintf("| %s | %s | %s | %s |\n",
			repo.Name, branch, lastCommit, remote))
	}

	sb.WriteString("\n---\n")
	sb.WriteString("*This file is auto-generated by metarepo-cli*\n")

	return sb.String()
}

func generateSimpleInventory(repos []*git.RepoInfo) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("# Repository Overview (%d repos)\n", len(repos)))
	sb.WriteString(fmt.Sprintf("# Generated: %s\n\n", time.Now().Format("2006-01-02 15:04:05")))

	for _, repo := range repos {
		sb.WriteString(fmt.Sprintf("%s\n", repo.Name))
		if repo.URL != "" {
			sb.WriteString(fmt.Sprintf("  url: %s\n", repo.URL))
		}
		sb.WriteString(fmt.Sprintf("  branch: %s\n", repo.Branch))
		if !repo.LastCommit.Date.IsZero() {
			sb.WriteString(fmt.Sprintf("  last_commit: %s\n", repo.LastCommit.Date.Format("2006-01-02")))
		}
		sb.WriteString("\n")
	}

	return sb.String()
}
